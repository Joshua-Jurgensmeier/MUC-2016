#pragma config(Sensor, S1,     sonic,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     colorPark,      sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     colorLine,      sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     colorRedS,      sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Motor,  motorA,          turner,        tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          driver,        tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Structs
struct vector {
	ubyte left_path;
	ubyte straight_path;
	ubyte right_path;
};

struct edge {
	ubyte destination;
	ubyte distance;
	ubyte parking_lot;
	ubyte start_lot;
};

// Variable initializations
const ubyte MAX_UBYTE = 255;	// Represents infinity]

const ubyte v_size = 16;			// Number of vectors
vector vertices[v_size];			// Array of vectors (1 based, 0 is used as undefined)
const ubyte p_size = 100;			// Number of Paths
edge paths[p_size];						// Array of paths (1 based, 0 is used as undefined)
ubyte path_counter = 1;				// Counter to keep track of which paths can be assigned to a vector

char directions[100][3];			// Array to keep track of the directions to get from source to destination
ubyte locations[5]; 					// Home -> Park1 -> Park2 -> Park3 -> Home
ubyte locations_paths[5];			// Path number that objective is on (unique for permutation function)
ubyte permutations[6][3];			// Permutations of locations_paths
ubyte permutations_l[6][3];		// Permutations of locations
ubyte current_location = 0;		// 0-4 Which objectives have been reached
bool visited[5];

// Creates a path and assigns the corresponding vector to it
void add_path(ubyte source, ubyte destination, char direction, ubyte distance, ubyte parking_lot, ubyte start_lot)
{
	// Assign the L,S,R direction on the vector to the new path
	if (direction == 'L') {
		vertices[source].left_path = path_counter;
	} else if (direction == 'S') {
		vertices[source].straight_path = path_counter;
	} else if (direction == 'R') {
		vertices[source].right_path = path_counter;
	}
	// Assign the information given to the path
	paths[path_counter].destination = destination;
	paths[path_counter].distance = distance;
	if (parking_lot >= 0) {
		paths[path_counter].parking_lot = parking_lot;
	}
	if (start_lot >= 0) {
		paths[path_counter].start_lot = start_lot;
	}
	// Increase the path_counter to a new unused path
	path_counter++;
}

// Removes a path from the graph
void remove_path(ubyte source, ubyte destination) {
	if (paths[vertices[source].left_path].destination == destination) {
		vertices[source].left_path = 0;
	} else if (paths[vertices[source].straight_path].destination == destination) {
		vertices[source].left_path = 0;
	} else if (paths[vertices[source].right_path].destination == destination) {
		vertices[source].left_path = 0;
	}
}

// Initalizes the graph with all the information needed
void graph_init() {
	add_path(1,3,'L',10,0,0);
	add_path(2,3,'L',5,0,0);
	add_path(3,7,'L',7,0,0);
	add_path(4,1,'L',7,0,1);
	add_path(5,2,'S',7,2,0);
	add_path(5,4,'R',5,0,0);
	add_path(6,2,'L',7,2,0);
	add_path(6,4,'S',5,0,0);
	add_path(7,6,'L',5,0,0);
	add_path(7,13,'S',15,4,0);
	add_path(8,9,'S',5,0,0);
	add_path(8,5,'R',8,0,0);
	add_path(9,13,'L',7,0,0);
	add_path(10,8,'L',5,0,0);
	add_path(10,15,'S',8,3,0);
	add_path(11,13,'L',4,0,0);
	add_path(12,11,'L',10,0,0);
	add_path(12,10,'S',3,0,0);
	add_path(13,14,'L',10,5,0);
	add_path(14,12,'L',4,0,0);
	add_path(15,1,'S',7,0,1);
}


ubyte dijkstra(ubyte source, ubyte destination) {
	ubyte dist[v_size];			// Holds the distance to vertices
	ubyte prev[v_size];			// Holds the vertex from whence it came
	char dir[v_size];			// Holds the direction from whence it came
	bool visited[v_size];	// Array of vertices to still visit
	ubyte c;								// Current vertex that is being searched

	// Array initialization
	for (ubyte v = 1; v < v_size; v++) {
		dist[v] = MAX_UBYTE;             		// Initialize to "infinity"
		prev[v] = 0;            					// Initialize to "undefined"
		dir[v] = 0;
		visited[v] = false;								// Initialize to not visited yet
	}

	// The source doesn't have to go anywhere to get where it is
	dist[source] = 0;

	// Loop through all vertices
	for (ubyte x = 1; x < v_size; x++) {

		// Find vertex with the shortest distance that we haven't visited yet
		ubyte min = MAX_UBYTE;															// Keeps track of the current shortest distance
		for (ubyte i = 1; i < v_size; i++) {							// Check all vertices
			if (visited[i] == false && dist[i] <= min) {	// Only update if we haven't visited the vertex yet and it's shorter than our current vertex
				min = dist[i];															// Update the shorest distance
				c = i;																			// Update the current vertex
			}
		}
		// Yay, we visited a node
		visited[c] = true;

		// Don't check anymore vertices if we have reached our destination
		if (c == destination) {
			break;
		}

		// Here be dragons (or not) :)
		// It checks to see if there are any paths connected to the current vertex,
		// then it checks if taking the new path would be any shorter than the current path there.
		// If it is then it updates the dist and prev array to the new values.
		if (vertices[c].left_path != 0) {
			ubyte path_to_neighbor = vertices[c].left_path;
			ubyte neighbor = paths[path_to_neighbor].destination;
			ubyte alt = dist[c] + paths[path_to_neighbor].distance;
			if (alt < dist[neighbor]) {
				dist[neighbor] = alt;
				prev[neighbor] = c;
				dir[neighbor] = 'L';
			}
		}
		if (vertices[c].straight_path != 0) {
			ubyte path_to_neighbor = vertices[c].straight_path;
			ubyte neighbor = paths[path_to_neighbor].destination;
			ubyte alt = dist[c] + paths[path_to_neighbor].distance;
			if (alt < dist[neighbor]) {
				dist[neighbor] = alt;
				prev[neighbor] = c;
				dir[neighbor] = 'S';
			}
		}
		if (vertices[c].right_path != 0) {
			ubyte path_to_neighbor = vertices[c].right_path;
			ubyte neighbor = paths[path_to_neighbor].destination;
			ubyte alt = dist[c] + paths[path_to_neighbor].distance;
			if (alt < dist[neighbor]) {
				dist[neighbor] = alt;
				prev[neighbor] = c;
				dir[neighbor] = 'R';
			}
		}
	}


	// Figure out directions to get from destination to source from prev[]
	for (int i = 0; i < 100; i++) {
		directions[i][0] = 0;
		directions[i][1] = 0;
		directions[i][2] = 0;
	}
	int count = 0;
	int current = destination;
	while (current != 0) {
		count++;
		directions[count][0] = dir[current];
		directions[count][1] = current;
		current = prev[current];
	}

	// The directions are backwards, so lets fix it by reversing it
	char tmp;
	int s = 0;
	int e = count-1;
	while (s < e) {
		tmp = directions[s][0];
		directions[s][0] = directions[e][0];
		directions[e][0] = tmp;
		tmp = directions[s][1];
		directions[s][1] = directions[e][1];
		directions[e][1] = tmp;
		s++;
		e--;
	}

	// All done
  return dist[destination];
}

void shortest_path() {

	// Reset locations_paths
	locations_paths[0] = 0;
	locations_paths[1] = 0;
	locations_paths[2] = 0;
	locations_paths[3] = 0;
	locations_paths[4] = 0;

	// Find the paths that contain the parking or starting lot
	// we are looking for and store that in locations_paths
	for (ubyte i = 0; i < p_size; i++) {
		if (locations[0] == paths[i].start_lot) {
			locations_paths[0] = i;
		} if (locations[1] == paths[i].parking_lot) {
			locations_paths[1] = i;
		} if (locations[2] == paths[i].parking_lot) {
			locations_paths[2] = i;
		} if (locations[3] == paths[i].parking_lot) {
			locations_paths[3] = i;
		} if (locations[4] == paths[i].start_lot) {
			locations_paths[4] = i;
		}
	}

	// Don't consider locations that we already visited
	for (int i = 0; i<5; i++) {
		if (visited[i]) {
			locations_paths[i] = 0;
		}
	}

	permutations[0][0] = locations_paths[1];
	permutations_l[0][0] = locations[1];
	permutations[0][1] = locations_paths[2];
	permutations_l[0][1] = locations[2];
	permutations[0][2] = locations_paths[3];
	permutations_l[0][2] = locations[3];

	permutations[1][0] = locations_paths[1];
	permutations_l[1][0] = locations[1];
	permutations[1][1] = locations_paths[3];
	permutations_l[1][1] = locations[3];
	permutations[1][2] = locations_paths[2];
	permutations_l[1][2] = locations[2];

	permutations[2][0] = locations_paths[2];
	permutations_l[2][0] = locations[2];
	permutations[2][1] = locations_paths[1];
	permutations_l[2][1] = locations[1];
	permutations[2][2] = locations_paths[3];
	permutations_l[2][2] = locations[3];

	permutations[3][0] = locations_paths[2];
	permutations_l[3][0] = locations[2];
	permutations[3][1] = locations_paths[3];
	permutations_l[3][1] = locations[3];
	permutations[3][2] = locations_paths[1];
	permutations_l[3][2] = locations[1];

	permutations[4][0] = locations_paths[3];
	permutations_l[4][0] = locations[3];
	permutations[4][1] = locations_paths[2];
	permutations_l[4][1] = locations[2];
	permutations[4][2] = locations_paths[1];
	permutations_l[4][2] = locations[1];

	permutations[5][0] = locations_paths[3];
	permutations_l[5][0] = locations[3];
	permutations[5][1] = locations_paths[1];
	permutations_l[5][1] = locations[1];
	permutations[5][2] = locations_paths[2];
	permutations_l[5][2] = locations[2];

	// Move all the 0s to the end of the array
	for (ubyte i = 0; i < 6; i++) {
		for (int z = 0; z < 2; z++) {
			if (permutations[i][z] == 0) {
				permutations[i][z] = permutations[i][z+1];
				permutations[i][z+1] = 0;
			}
		}
	}

	// Calculate the distances of all the route permutations

	ubyte total_dists[6];	// Stores the total distances of the route permutations
	// Initialize it
	for (ubyte i = 0; i < 6; i++) {
		total_dists[i] = 0;
	}
	// Loop through each permutation of the route and calculate the total distance of each
	for (ubyte i = 0; i < 6 && permutations[i][0] != 0; i++) {
		writeDebugStreamLine("Route: %d",i);

		// Special case measuring the distance from start to the first parking lot
		if (current_location == 0) {
			total_dists[i] += dijkstra(paths[locations_paths[0]].destination, paths[permutations[i][0]].destination);
			writeDebugStreamLine("%d %d",paths[locations_paths[0]].destination, paths[permutations[i][0]].destination);
		}

		ubyte x = 0;	// Needed to find the last parking lot
		// Measures the distance between each of the parking lots
		for (; x < 2 && permutations[i][x+1] != 0; x++) {
			total_dists[i] += dijkstra(paths[permutations[i][x]].destination, paths[permutations[i][x+1]].destination);
			writeDebugStreamLine("%d %d",paths[permutations[i][x]].destination, paths[permutations[i][x+1]].destination);
		}

		// Special case measuring distance from last parking lot back home
		total_dists[i] += dijkstra(paths[permutations[i][x]].destination, paths[locations_paths[4]].destination);
		writeDebugStreamLine("%d %d",paths[permutations[i][x]].destination, paths[locations_paths[4]].destination);
	}

	// Find shortest route out of total_dists
	ubyte min_index = 0;		// Stores the route that is the shortest
	ubyte min = MAX_UBYTE;	// Set the minimum to "infinity"
	for (ubyte i = 0; i < 6 && total_dists[i] != 0; i++) {
		if (total_dists[i] < min) {
			min_index = i;
			min = total_dists[i];
		}
	}

	writeDebugStreamLine("");
	writeDebugStreamLine("Shortest route: %d",min);
	writeDebugStreamLine("Shortest route number: %d",min_index);
	writeDebugStreamLine("");

	// Generate directions

	ubyte tmp_directions[100][3];	// Tempoarily stores the combined directions
	ubyte directions_index = 0;		// Keeps track of where we are storing at in tmp_directions

	// Initialize array
	for (ubyte i = 0; i < 100; i++) {
		tmp_directions[i][0] = 0;
		tmp_directions[i][1] = 0;
		tmp_directions[i][2] = 0;
	}

	tmp_directions[0][0] = 'L';	// Leave start space
	directions_index++;

	// If we are still at the start then add directions from start to the first parking lot
	if (current_location == 0) {
		// Update global directions
		dijkstra(paths[locations_paths[0]].destination, paths[permutations[min_index][0]].destination);

		// Loop through the global directions and add it to the local directions
		for (ubyte i = 0; directions[i][0] != 0; i++) {
			tmp_directions[directions_index][0] = directions[i][0];
			tmp_directions[directions_index][1] = directions[i][1];

			// If it is the last direction to the parking lot, then note that we need to park
			if (directions[i+1][0] == 0) {
				// Note the home and end locations
				tmp_directions[directions_index][2] = permutations_l[min_index][0];
			}

			directions_index++;
		}
	}

	// For as many parking lots are left, calculate directions between them
	ubyte x = 0;
	for (; x < 2 && permutations[min_index][x+1] != 0; x++) {
		dijkstra(paths[permutations[min_index][x]].destination, paths[permutations[min_index][x+1]].destination);

		// Loop through the global directions and add it to the local directions
		for (ubyte i = 0; directions[i][0] != 0; i++) {
			tmp_directions[directions_index][0] = directions[i][0];
			tmp_directions[directions_index][1] = directions[i][1];

			// If it is the last direction to the parking lot, then note that we need to park
			if (directions[i+1][0] == 0) {
				// Note the lot we are going to
				tmp_directions[directions_index][2] = permutations_l[min_index][x+1];
			}
			directions_index++;
		}
	}

	// Update directions to be from the last parking lot back home
	dijkstra(paths[permutations[min_index][x]].destination, paths[locations_paths[4]].destination);

	// Loop through the global directions and add it to the local directions
	for (ubyte i = 0; directions[i][0] != 0; i++) {
			tmp_directions[directions_index][0] = directions[i][0];
			tmp_directions[directions_index][1] = directions[i][1];

			// If it is the last direction to the parking lot, then note that we need to park
			if (directions[i+1][0] == 0) {
				// Note the end locations
				tmp_directions[directions_index][2] = locations[4];
			}
			directions_index++;
	}

	// Copy local complete directions to global array
	for (ubyte i = 0; i < 100; i++) {
		directions[i][0] = tmp_directions[i][0];	// Turn Direction
		directions[i][1] = tmp_directions[i][1];	// Path we are taking
		directions[i][2] = tmp_directions[i][2];	// Lot we are going to if any
	}
}

// Mark a parking lot as having been visited
void visited_objective(ubyte lot) {
	for (int i = 0; i<5; i++) {
		if (locations[i] == lot) {
			visited[i] = true;
		}
	}
	current_location++;
}

//A function that turns the front motor
//negative is left
//positive is right
void turn(int turnDegrees)
{

	int motorDegrees = (turnDegrees * 7.2);


	if (motorDegrees < nMotorEncoder[turner])
	{
		while(nMotorEncoder[turner] > motorDegrees)
		{
			motor[turner] = -100;

		}
		motor[turner] = 0;
	}
	else
	{
		while(nMotorEncoder[turner] < motorDegrees)
		{
			motor[turner] = 100;
		}
		motor[turner] = 0;
	}
}


void followLine()
{
	int viewDistance = 100;

	string direction = "";
	//The driving motor power is initially set to 20.
	motor[driver] = 20;

	while(SensorValue[S4] < 70)
	{
		//If there is an object in our way slow down
		//if(SensorValue[sonic] < viewDistance)
		//{
		//	motor[driver] = 10;
		//}
		//else
		//{
		//	motor[driver] = 20;
		//}


		if((SensorValue[colorLine] == 6) && (direction == "right" || direction == ""))
		{
			turn(-15);
			direction = "left";
		}

		else if((SensorValue[colorLine] == 3) && (direction == "left" || direction == ""))
		{
			turn(7);
			direction = "right";
		}
	}
}

//A function that issues a motor command and then waits for it to finish.
void drive(int degrees, int motorPower)
 {
  nMotorEncoder[driver] = 0;

	moveMotorTarget(driver, degrees, motorPower);

 	while(getMotorRunning(driver) == 1)
 	{
  	//idle
 	}
}

void right_of_way(char direction) {

	//How far the ultrasonic is looking for objects.
	//Measurement is in centimeters
	int viewDistance = 60;

	//If we are turning left
	if (direction == 'L') {

		//Turn the ultrasonic to the right
		turn(60);

		//Check the ultrasonic.
		if (SensorValue[sonic] < viewDistance) {

			//Turn the ultrasonic straight
			turn(0);

			//Back up 100 degrees so that collisions are avoided
			drive(-100, -30);

			//wait for nine seconds per regulation
			delay(9000);

			//Check the ultrasonic every 3 seconds
			//to see if the intersection is clear
			do
			{
				delay(3000);
			}
			while (SensorValue[sonic] < viewDistance);
		}
		//If the ultrasonic doesn't see anyone
		//Turn it back straight.
		else
		{
			turn(0);
		}
	}

	//If we are driving straight.
	else if (direction == 'S') {

		//Turn the ultrasonic to the left
		turn(-60);

		//Check the ultrasonic.
		if (SensorValue[sonic] < viewDistance)
		{
			//Turn the ultrasonic straight
			turn(0);

			//Back up 100 degrees so that collisions are avoided
			drive(-100, -30);

			//wait for three seconds per regulation
			delay(3000);

			//Check the ultrasonic every 3 seconds
			//to see if the intersection is clear
			do
			{
				delay(3000);
			}
			while (SensorValue[sonic] < viewDistance);
		}

		//If there is nothing to our left, then we still need to check the right
		else
		{
			//Turn the ultrasonic to the right
			turn(60);

			//Check the ultrasonic.
			if (SensorValue[sonic] < viewDistance) {
				//Turn the ultrasonic straight
				turn(0);

				//Back up 100 degrees so that collisions are avoided
				drive(-100, -30);

				//Wait 9 seconds per regultaion.
				delay(9000);

				//Check the ultrasonic every 3 seconds
			  //to see if the intersection is clear
				do
				{
					delay(3000);
				}
				while (SensorValue[sonic] < viewDistance);
			}
			//If the  ultrasonic doesn't see anyone, all's clear (theoretically)
			else
			{
				//Turn the ultrasonic back straight
				turn(0);
			}
		}
	}
	else if (direction == 'R')
	{
		//Turn the ultrasonic to the left
		turn(-60);

		//Check the ultrasonic.
		if (SensorValue[sonic] < viewDistance)
		{
			//Turn the ultrasonic back straight
			turn(0);

			//Back up 100 degrees so that collisions are avoided
			drive(-100, -30);

			//Wait 3 seconds per regulation
			delay(3000);

			//Check the ultrasonic every 3 seconds
			//to see if the intersection is clear
			do
			{
				delay(3000);
			}
			while (SensorValue[sonic] < viewDistance);
		}

		//If the  ultrasonic doesn't see anyone, all's clear (theoretically)
		else
		{
			//Turn the ultrasonic back straight
			turn(0);
		}
	}

	//Proceed forward through the intersection.
	drive(200, 30);
}


void TurnLeft()
{

	drive(450, 20);

	turn(-57);

	while(SensorValue(colorPark) == 3/*(SensorValue(colorPark) != 6) || (SensorValue(colorPark) != 2)*/)
	{
		motor[driver] = 5;
	}

	motor[driver] = 0;

	turn(0);
	turn(0);
}


void TurnRight()
{

	drive(450, 20);

	turn(57);

	while(SensorValue(colorPark) == 3/*(SensorValue(colorPark) != 6) || (SensorValue(colorPark) != 2)*/)
	{
		motor[driver] = 10;
	}

	motor[driver] = 0;

	turn(0);
}

void TurnStraight()
{
	turn(0);
	drive(450,20);
}

task main()
{
	clearDebugStream();
	graph_init();

	locations[0] = 1;
	locations[1] = 3;
	locations[2] = 4;
	locations[3] = 2;
	locations[4] = 1;
	shortest_path();

	for (ubyte i = 0; directions[i][0] != 0; i++)
	{
		writeDebugStreamLine("Step: %c %i %i", directions[i][0], directions[i][1], directions[i][2]);
		if (directions[i][0] == 'L') {
			TurnLeft();
		}
		else if (directions[i][0] == 'R')
		{
			TurnRight();
		}
		else if (directions[i][0] == 'S')
		{
			TurnStraight();
		}
		followLine();
		turn(0);
	}
}
