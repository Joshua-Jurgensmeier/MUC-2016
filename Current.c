#pragma config(Sensor, S1,     sonic,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     colorPark,      sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     colorLine,      sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     colorStopLine,  sensorEV3_Color, modeEV3Color_RGB_Raw)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Structs
struct vector
{
	ubyte leftPath;
	ubyte straightPath;
	ubyte rightPath;
};

struct edge
{
	ubyte destination;
	ubyte distance;
	ubyte parkingLot;
	ubyte startLot;
};

// Variable initializations
const ubyte INFINITY = 255;		// Represents infinity

const ubyte vSize = 16;				// Number of vectors
vector vertices[vSize];			// Array of vectors (1 based, 0 is used as undefined)

const ubyte pSize = 100;			// Number of Paths
ubyte pathCounter = 1;				// Counter to keep track of which paths can be assigned to a vector
edge paths[pSize];						// Array of paths (1 based, 0 is used as undefined)

char directions[100][3];			// Array to keep track of the directions to get from source to destination
ubyte locations[5]; 					// Home -> Park1 -> Park2 -> Park3 -> Home
ubyte locationPaths[5];			// Path number that objective is on (unique for permutation function)
ubyte permutationPaths[6][3];			// Permutations of locations_paths
ubyte permutationLocations[6][3];		// Permutations of locations
ubyte currentLocation = 0;		// 0-4 Which objectives have been reached
bool visited[5];

// Creates a path and assigns the corresponding vector to it
void AddPath(ubyte source, ubyte destination, char direction, ubyte distance, ubyte parkingLot, ubyte startLot)
{
	// Assign the L,S,R direction on the vector to the new path
	if (direction == 'L')
	{
		vertices[source].leftPath = pathCounter;
	}

	else if (direction == 'S')
	{
		vertices[source].straightPath = pathCounter;
	}

	else if (direction == 'R')
	{
		vertices[source].right_path = path_counter;
	}

	// Assign the information given to the path
	paths[pathCounter].destination = destination;
	paths[pathCounter].distance = distance;

	if (parkingLot >= 0)
	{
		paths[pathCounter].parkingLot = parkingLot;
	}

	if (startLot >= 0)
	{
		paths[pathCounter].startLot = startLot;
	}

	// Increase the path_counter to a new unused path
	pathCounter++;
}

// Removes a path from the graph
void removePath(ubyte source, ubyte destination)
{
	if (paths[vertices[source].leftPath].destination == destination)
	{
		vertices[source].leftPath = 0;
	}

	else if (paths[vertices[source].straightPath].destination == destination)
	{
		vertices[source].leftPath = 0;
	}

	else if (paths[vertices[source].rightPpath].destination == destination)
	{
		vertices[source].leftPath = 0;
	}
}

// Initalizes the graph with all the information needed
void createMap() {
	addPath(1,3,'L',10,0,0);
	addPath(2,3,'L',5,0,0);
	addPath(3,7,'L',7,0,0);
	addPath(4,1,'L',7,0,1);
	addPath(5,2,'S',7,2,0);
	addPath(5,4,'R',5,0,0);
	addPath(6,2,'L',7,2,0);
	addPath(6,4,'S',5,0,0);
	addPath(7,6,'L',5,0,0);
	addPath(7,13,'S',15,4,0);
	addPath(8,9,'S',5,0,0);
	addPath(8,5,'R',8,0,0);
	addPath(9,13,'L',7,0,0);
	addPath(10,8,'L',5,0,0);
	addPath(10,15,'S',8,3,0);
	addPath(11,13,'L',4,0,0);
	addPath(12,11,'L',10,0,0);
	addPath(12,10,'S',3,0,0);
	addPath(13,14,'L',10,5,0);
	addPath(14,12,'L',4,0,0);
	addPath(15,1,'S',7,0,1);
}


ubyte dijkstra(ubyte source, ubyte destination)
{
	ubyte dist[vSize];			// Holds the distance to vertices
	ubyte prev[vSize];			// Holds the vertex from whence it came
	char dir[vSize];				// Holds the direction from whence it came
	bool visited[vSize];		// Array of vertices to still visit
	ubyte c;								// Current vertex that is being searched

	// Array initialization
	for (ubyte v = 1; v < vSize; v++)
	{
		dist[v] = INFINITY;             		// Initialize to "infinity"
		prev[v] = 0;            					// Initialize to "undefined"
		dir[v] = 0;
		visited[v] = false;								// Initialize to not visited yet
	}

	// The source doesn't have to go anywhere to get where it is
	dist[source] = 0;

	// Loop through all vertices
	for (ubyte x = 1; x < vSize; x++)
	{

		// Find vertex with the shortest distance that we haven't visited yet
		ubyte min = INFINITY;													// Keeps track of the current shortest distance
		for (ubyte i = 1; i < vSize; i++)							// Check all vertices
		{
			if (visited[i] == false && dist[i] <= min)		// Only update if we haven't visited the vertex yet and it's shorter than our current vertex
			{
				min = dist[i];															// Update the shorest distance
				c = i;																			// Update the current vertex
			}
		}

		// Yay, we visited a node
		visited[c] = true;

		// Don't check anymore vertices if we have reached our destination
		if (c == destination)
		{
			break;
		}

		// It checks to see if there are any paths connected to the current vertex,
		// then it checks if taking the new path would be any shorter than the current path to the vertex.
		// If it is shorter then it updates the dist and prev array to the new values.
		if (vertices[c].leftPath != 0)
		{
			ubyte pathToNeighbor = vertices[c].leftPath;
			ubyte neighbor = paths[pathToNeighbor].destination;
			ubyte alt = dist[c] + paths[pathToNeighbor].distance;

			if (alt < dist[neighbor])
			{
				dist[neighbor] = alt;
				prev[neighbor] = c;
				dir[neighbor] = 'L';
			}
		}
		if (vertices[c].straightPath != 0)
		{
			ubyte pathToNeighbor = vertices[c].straightPath;
			ubyte neighbor = paths[pathToNeighbor].destination;
			ubyte alt = dist[c] + paths[pathToNeighbor].distance;

			if (alt < dist[neighbor])
			{
				dist[neighbor] = alt;
				prev[neighbor] = c;
				dir[neighbor] = 'S';
			}
		}
		if (vertices[c].right_path != 0)
		{
			ubyte pathToNeighbor = vertices[c].rightPath;
			ubyte neighbor = paths[pathToNeighbor].destination;
			ubyte alt = dist[c] + paths[pathToNeighbor].distance;

			if (alt < dist[neighbor])
			{
				dist[neighbor] = alt;
				prev[neighbor] = c;
				dir[neighbor] = 'R';
			}
		}
	}


	// Figure out directions to get from destination to source from prev[]

	// Clear directions array
	for (int i = 0; i < 100; i++)
	{
		directions[i][0] = 0;
		directions[i][1] = 0;
		directions[i][2] = 0;
	}

	int count = 0;
	int current = destination;

	while (current != 0)
	{
		count++;
		directions[count][0] = dir[current];
		directions[count][1] = current;
		current = prev[current];
	}

	// The directions are backwards, so lets fix it by reversing it
	char tmp;
	int s = 0;
	int e = count-1;

	while (s < e)
	{
		tmp = directions[s][0];
		directions[s][0] = directions[e][0];
		directions[e][0] = tmp;

		tmp = directions[s][1];
		directions[s][1] = directions[e][1];
		directions[e][1] = tmp;

		s++;
		e--;
	}

	// All done
  return dist[destination];
}

void shortestPath()
{

	// Reset locations_paths
	locationPaths[0] = 0;
	locationPaths[1] = 0;
	locationPaths[2] = 0;
	locationPaths[3] = 0;
	locationPaths[4] = 0;

	// Find the paths that contain the parking or starting lot
	// we are looking for and store that in locations_paths
	for (ubyte i = 0; i < pSize; i++)
	{
		if (locations[0] == paths[i].startLot)
		{
			locationPaths[0] = i;
		}

		if (locations[1] == paths[i].parkingLot)
		{
			locationPaths[1] = i;
		}

		if (locations[2] == paths[i].parkingLot)
		{
			locationPaths[2] = i;
		}

		if (locations[3] == paths[i].parkingLot)
		{
			locationPaths[3] = i;
		}

		if (locations[4] == paths[i].startLot)
		{
			locationPaths[4] = i;
		}
	}

	// Don't consider locations that we already visited
	for (int i = 0; i < 5; i++)
	{
		if (visited[i])
		{
			locationPaths[i] = 0;
		}
	}

	// Put all the possible permutations in the permutations array
	permutationPaths[0][0] = locationPaths[1];
	permutationLocations[0][0] = locations[1];
	permutationPaths[0][1] = locationPaths[2];
	permutationLocations[0][1] = locations[2];
	permutationPaths[0][2] = locationPaths[3];
	permutationLocations[0][2] = locations[3];

	permutationPaths[1][0] = locationPaths[1];
	permutationLocations[1][0] = locations[1];
	permutationPaths[1][1] = locationPaths[3];
	permutationLocations[1][1] = locations[3];
	permutationPaths[1][2] = locationPaths[2];
	permutationLocations[1][2] = locations[2];

	permutationPaths[2][0] = locations_paths[2];
	permutationLocations[2][0] = locations[2];
	permutationPaths[2][1] = locations_paths[1];
	permutationLocations[2][1] = locations[1];
	permutationPaths[2][2] = locations_paths[3];
	permutationLocations[2][2] = locations[3];

	permutationPaths[3][0] = locations_paths[2];
	permutationLocations[3][0] = locations[2];
	permutationPaths[3][1] = locations_paths[3];
	permutationLocations[3][1] = locations[3];
	permutationPaths[3][2] = locations_paths[1];
	permutationLocations[3][2] = locations[1];

	permutationPaths[4][0] = locations_paths[3];
	permutationLocations[4][0] = locations[3];
	permutationPaths[4][1] = locations_paths[2];
	permutationLocations[4][1] = locations[2];
	permutationPaths[4][2] = locations_paths[1];
	permutationLocations[4][2] = locations[1];

	permutationPaths[5][0] = locations_paths[3];
	permutationLocations[5][0] = locations[3];
	permutationPaths[5][1] = locations_paths[1];
	permutationLocations[5][1] = locations[1];
	permutationPaths[5][2] = locations_paths[2];
	permutationLocations[5][2] = locations[2];

	// Move all the 0s to the end of the array
	for (ubyte i = 0; i < 6; i++)
	{
		for (ubyte z = 0; z < 2; z++)
		{
			if (permutationPaths[i][z] == 0)
			{
				permutationPaths[i][z] = permutationPaths[i][z+1];
				permutationPaths[i][z+1] = 0;
			}
		}
	}

	// Calculate the distances of all the route permutations

	ubyte total_dists[6];	// Stores the total distances of the route permutations

	// Initialize it
	for (ubyte i = 0; i < 6; i++)
	{
		totalDists[i] = 0;
	}

	// Loop through each permutation of the route and calculate the total distance of each
	for (ubyte i = 0; i < 6 && permutationPaths[i][0] != 0; i++)
	{
		writeDebugStreamLine("Route: %d",i);

		// Special case measuring the distance from start to the first parking lot
		if (currentLocation == 0)
		{
			totalDists[i] += dijkstra(paths[locationPaths[0]].destination, paths[permutationPaths[i][0]].destination);

			writeDebugStreamLine("%d %d",paths[locationPaths[0]].destination, paths[permutationPaths[i][0]].destination);
		}

		ubyte x = 0;	// Needed to find the last parking lot

		// Measures the distance between each of the parking lots
		for (; x < 2 && permutationPaths[i][x+1] != 0; x++)
		{
			totalDists[i] += dijkstra(paths[permutationPaths[i][x]].destination, paths[permutationPaths[i][x+1]].destination);

			writeDebugStreamLine("%d %d",paths[permutationPaths[i][x]].destination, paths[permutationPaths[i][x+1]].destination);
		}

		// Special case measuring distance from last parking lot back home
		totalDists[i] += dijkstra(paths[permutationPaths[i][x]].destination, paths[locationsPpaths[4]].destination);

		writeDebugStreamLine("%d %d",paths[permutationPaths[i][x]].destination, paths[locationsPaths[4]].destination);
	}

	// Find shortest route out of total_dists
	ubyte minIndex = 0;		// Stores the route that is the shortest
	ubyte min = INFINITY;	// Set the minimum to "infinity"

	for (ubyte i = 0; i < 6 && totalDists[i] != 0; i++)
	{
		if (totalDists[i] < min)
		{
			minIndex = i;
			min = totalDists[i];
		}
	}

	writeDebugStreamLine("");
	writeDebugStreamLine("Shortest route: %d",min);
	writeDebugStreamLine("Shortest route number: %d",min_index);
	writeDebugStreamLine("");

	// Generate directions

	ubyte tmpDirections[100][3];	// Tempoarily stores the combined directions
	ubyte directionsIndex = 0;		// Keeps track of where we are storing at in tmp_directions

	// Initialize array
	for (ubyte i = 0; i < 100; i++)
	{
		tmpDirections[i][0] = 0;
		tmpDirections[i][1] = 0;
		tmpDirections[i][2] = 0;
	}

	tmpDirections[0][0] = 'L';	// Leave start space
	directionsIndex++;

	// If we are still at the start then add directions from start to the first parking lot
	if (currentLocation == 0)
	{
		// Update global directions
		dijkstra(paths[locationPaths[0]].destination, paths[permutationPaths[minIndex][0]].destination);

		// Loop through the global directions and add it to the local directions
		for (ubyte i = 0; directions[i][0] != 0; i++)
		{
			tmpDirections[directionsIndex][0] = directions[i][0];
			tmpDirections[directionsIndex][1] = directions[i][1];

			// If it is the last direction to the parking lot, then note that we need to park
			if (directions[i+1][0] == 0)
			{
				// Note the home and end locations
				tmpDirections[directionsIndex][2] = permutationLocations[minIndex][0];
			}

			directionsIndex++;
		}
	}

	// For as many parking lots are left, calculate directions between them
	ubyte x = 0;

	for (; x < 2 && permutationPaths[minIndex][x+1] != 0; x++)
	{
		dijkstra(paths[permutationPaths[minIndex][x]].destination, paths[permutationPaths[minIndex][x+1]].destination);

		// Loop through the global directions and add it to the local directions
		for (ubyte i = 0; directions[i][0] != 0; i++)
		{
			tmpDirections[directionsIndex][0] = directions[i][0];
			tmpDirections[directionsIndex][1] = directions[i][1];

			// If it is the last direction to the parking lot, then note that we need to park
			if (directions[i+1][0] == 0)
			{
				// Note the lot we are going to
				tmpDirections[directionsIndex][2] = permutationLocations[minIndex][x+1];
			}

			directionsIndex++;
		}
	}

	// Update directions to be from the last parking lot back home
	dijkstra(paths[permutations[minIndex][x]].destination, paths[locationPaths[4]].destination);

	// Loop through the global directions and add it to the local directions
	for (ubyte i = 0; directions[i][0] != 0; i++)
	{
			tmpDirections[directionsIndex][0] = directions[i][0];
			tmpDirections[directionsIndex][1] = directions[i][1];

			// If it is the last direction to the parking lot, then note that we need to park
			if (directions[i+1][0] == 0)
			{
				// Note the end locations
				tmpDirections[directionsIndex][2] = locations[4];
			}

			directionsIndex++;
	}

	// Copy local complete directions to global array
	for (ubyte i = 0; i < 100; i++)
	{
		directions[i][0] = tmpDirections[i][0];	// Turn Direction
		directions[i][1] = tmpDirections[i][1];	// Path we are taking
		directions[i][2] = tmpDirections[i][2];	// Lot we are going to if any
	}
}

// Mark a parking lot as having been visited
void visitedObjective(ubyte lot)
{
	for (int i = 0; i<5; i++)
	{
		if (locations[i] == lot)
		{
			visited[i] = true;
		}
	}

	currentLocation++;
}

//A function that turns the front motor
//negative is left
//positive is right
void turn(int turnDegrees)
{
	int motorDegrees = (turnDegrees * 7.2);

	if (motorDegrees < nMotorEncoder[turner])
	{
		while(nMotorEncoder[turner] > motorDegrees)
		{
			motor[turner] = -100;

		}
		motor[turner] = 0;
	}

	else
	{
		while(nMotorEncoder[turner] < motorDegrees)
		{
			motor[turner] = 100;
		}
		motor[turner] = 0;
	}
}


void followLine()
{
	int viewDistance = 100;
	string direction = "";

	//The driving motor power is initially set to 20.
	motor[driver] = 20;

	while(SensorValue[colorStopLine] < 70)
	{
		//If there is an object in our way slow down
		//if(SensorValue[sonic] < viewDistance)
		//{
		//	motor[driver] = 10;
		//}
		//else
		//{
		//	motor[driver] = 20;
		//}

		if((SensorValue[colorLine] == 6) && (direction == "right" || direction == ""))
		{
			turn(-15);
			direction = "left";
		}

		else if((SensorValue[colorLine] == 3) && (direction == "left" || direction == ""))
		{
			turn(7);
			direction = "right";
		}
	}
}

//A function that issues a motor command and then waits for it to finish.
void drive(int degrees, int motorPower)
 {
  nMotorEncoder[driver] = 0;

	moveMotorTarget(driver, degrees, motorPower);

 	while(getMotorRunning(driver) == 1)
 	{
  	//idle
 	}
}

void rightOfWay(char direction) {

	//How far the ultrasonic is looking for objects.
	//Measurement is in centimeters
	int viewDistance = 60;

	//If we are turning left
	if (direction == 'L')
	{

		//Turn the ultrasonic to the right
		turn(60);

		//Check the ultrasonic.
		if (SensorValue[sonic] < viewDistance)
		{

			//Turn the ultrasonic straight
			turn(0);

			//Back up 100 degrees so that collisions are avoided
			drive(-100, -30);

			//wait for nine seconds per regulation
			delay(9000);

			//Check the ultrasonic every 3 seconds
			//to see if the intersection is clear
			do
			{
				delay(3000);
			} while (SensorValue[sonic] < viewDistance);
		}

		//If the ultrasonic doesn't see anyone
		//Turn it back straight.
		else
		{
			turn(0);
		}
	}

	//If we are driving straight.
	else if (direction == 'S')
	{

		//Turn the ultrasonic to the left
		turn(-60);

		//Check the ultrasonic.
		if (SensorValue[sonic] < viewDistance)
		{
			//Turn the ultrasonic straight
			turn(0);

			//Back up 100 degrees so that collisions are avoided
			drive(-100, -30);

			//wait for three seconds per regulation
			delay(3000);

			//Check the ultrasonic every 3 seconds
			//to see if the intersection is clear
			do
			{
				delay(3000);
			} while (SensorValue[sonic] < viewDistance);
		}

		//If there is nothing to our left, then we still need to check the right
		else
		{
			//Turn the ultrasonic to the right
			turn(60);

			//Check the ultrasonic.
			if (SensorValue[sonic] < viewDistance)
			{
				//Turn the ultrasonic straight
				turn(0);

				//Back up 100 degrees so that collisions are avoided
				drive(-100, -30);

				//Wait 9 seconds per regultaion.
				delay(9000);

				//Check the ultrasonic every 3 seconds
			  //to see if the intersection is clear
				do
				{
					delay(3000);
				} while (SensorValue[sonic] < viewDistance);
			}

			//If the  ultrasonic doesn't see anyone, all's clear (theoretically)
			else
			{
				//Turn the ultrasonic back straight
				turn(0);
			}
		}
	}

	else if (direction == 'R')
	{
		//Turn the ultrasonic to the left
		turn(-60);

		//Check the ultrasonic.
		if (SensorValue[sonic] < viewDistance)
		{
			//Turn the ultrasonic back straight
			turn(0);

			//Back up 100 degrees so that collisions are avoided
			drive(-100, -30);

			//Wait 3 seconds per regulation
			delay(3000);

			//Check the ultrasonic every 3 seconds
			//to see if the intersection is clear
			do
			{
				delay(3000);
			} while (SensorValue[sonic] < viewDistance);
		}

		//If the  ultrasonic doesn't see anyone, all's clear (theoretically)
		else
		{
			//Turn the ultrasonic back straight
			turn(0);
		}
	}

	//Proceed forward through the intersection.
	drive(200, 30);
}


void turnLeft()
{
	drive(450, 20);

	turn(-57);

	while(SensorValue(colorPark) == 3)
	{
		motor[driver] = 5;
	}

	motor[driver] = 0;

	turn(0);
}


void turnRight()
{
	drive(450, 20);

	turn(57);

	while(SensorValue(colorPark) == 3)
	{
		motor[driver] = 10;
	}

	motor[driver] = 0;

	turn(0);
}

void driveStraight()
{
	turn(0);
	drive(450,20);
}

task main()
{
	clearDebugStream();
	createMap();

	locations[0] = 1;
	locations[1] = 3;
	locations[2] = 4;
	locations[3] = 2;
	locations[4] = 1;
	shortestPath();

	for (ubyte i = 0; directions[i][0] != 0; i++)
	{
		writeDebugStreamLine("Step: %c %i %i", directions[i][0], directions[i][1], directions[i][2]);

		if (directions[i][0] == 'L')
		{
			turnLeft();
		}

		else if (directions[i][0] == 'R')
		{
			turnRight();
		}

		else if (directions[i][0] == 'S')
		{
			driveStraight();
		}

		followLine();

		turn(0);
	}
}
